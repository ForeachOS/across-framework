[[across-core]]
== Across core

[discrete]
=== Artifact
[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>across</groupId>
			<artifactId>across-core</artifactId>
			<version>{across-version}</version>
		</dependency>
	</dependencies>
----

=== Dependencies

=== Creating an AcrossContext
==== Manual creation of an AcrossContext
An `AcrossContext` can be configured manually and is started using the `bootstrap()` method, and stopped using `shutdown()`.
These methods take care of the Spring `ApplicationContext` lifecycle of all modules configured in the context.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
AcrossContext context = new AcrossContext();
context.setParentApplicationContext( optionalParentContext );
context.setDataSource( someDataSource );
context.addModule( new SomeModule() );

// Start the context
context.bootstrap();

// Stop the context
context.shutdown();
----

==== Using @EnableAcrossContext and AcrossContextConfigurer
Usually your application will consist of a single `AcrossContext` that is configured in the main Spring `ApplicationContext`.
You can enable the automatic creation of an `AcrossContext` by putting the `@EnableAcrossContext` on any `@Configuration` class.
This will initialize a new `AcrossContext` with the main `ApplicationContext` as parent, look for a default datasource bean named
`acrossDataSource` and then delegate context configuration to all `AcrossContextConfigurer` beans it can find in the `ApplicationContext` before bootstrapping.

The `AcrossContext` will be configured with sensible defaults but all settings can be overridden in any `AcrossContextConfigurer`.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Configuration
@EnableAcrossContext
public class WebConfiguration implements AcrossContextConfigurer
{
	@Bean
	public DataSource acrossDataSource() {
		BasicDataSource dataSource = new BasicDataSource();
		dataSource.setDriverClassName( "org.hsqldb.jdbc.JDBCDriver" );
		dataSource.setUrl( "jdbc:hsqldb:mem:/hsql/testDataSource" );
		dataSource.setUsername( "sa" );
		dataSource.setPassword( "" );

		return dataSource;
	}

	@Override
	public void configure( AcrossContext context ) {
		context.setDevelopmentMode( true );

		context.addModule( new SomeModule() );
	}
}
----

=== Sharing beans between modules (exposing)
A module can share its beans with other modules by *exposing* them.  All exposed beans from a module are pushed upwards into the parent
`ApplicationContext` of the `AcrossContext` itself.  Likewise, at the end of the context bootstrap, all exposed beans are pushed into the
`ApplicationContext` that is - optionally - configured as the parent of the `AcrossContext`.

Which beans are exposed is determined by the `exposeFilter` property on an `AcrossModule`.  By default all beans annotated with `@Exposed`
or `@Service` will be exposed.  See the `com.foreach.across.core.filters.BeanFilter` implementations for standard filters.

When pushing beans to the parent `ApplicationContext` it is possible to run into name conflicts or duplicate bean types.
You can use an `ExposedBeanDefinitionTransformer` to modify the bean definitions that are pushed to the parent.  Common examples
for this are changing the bean names or marking the beans as primary.  You can set the transformer to use through the
`exposeTransformer` property on an `AcrossModule` or the `AcrossContext`.

ExposedBeanDefinitionTransformer on AcrossModule:: will be applied when pushing beans from the module into the `AcrossContext`
ExposedBeanDefinitionTransformer on AcrossModule:: will be applied when pushing beans from the `AcrossContext` into the parent `ApplicationContext`

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
public class SomeModule extends AcrossModule
{
	/**
	 * Only expose specific beans from this module and ensure that
	 * they have a prefixed bean name for the other modules.
	 */
	public SomeModule() {
		setExposeFilter( new ClassBeanFilter( PlatformTransactionManager.class, SessionFactory.class ) );
		setExposeTransformer( new BeanPrefixingTransformer( "someModule" ) );
	}
}
----

Beans created directly in the `AcrossContext` scope - and not inside one of the modules - will only be exposed if they are annotated
explicitly with `@Exposed`.  The `AcrossContext` does not support a custom `exposeFilter` but you can supply an additional
`exposeTransformer` on the context level. If you want to avoid an `AcrossContext` to push the exposed beans further upwards into its parent `ApplicationContext`, you should
configure the `ExposedBeanDefinitionTransformer.REMOVE_ALL` as `exposeTransformer` on the `AcrossContext` itself.  For an `AcrossModule`
using the `REMOVE_ALL` transformer would be the same as putting `null` as `exposeFilter`.

=== Datasources and installers
An `AcrossContext` requires at least one datasource if modules need to run installers.  Certain core features like the
`DistributedLockRepository` also require the core schema to be installed and will require a valid datasource to be configured.

The main datasource is available for all modules as a bean named `acrossDataSource`. Optionally a separate installer datasource
can be configured that will be available as `acrossInstallerDataSource`.  If no separate installer datasource is specified,
the default across datasource will be used.

IMPORTANT: A valid default datasource is always required for installers to run. It is not possible to configure only an installer
datasource as the distributed locking mechanism uses the default datasource.

The installer datasource can be wired anywhere, but will be the default datasource used for all `AcrossLiquibaseInstaller instances.
Its purpose is to provide a separate datasource with augmented permissions to perform schema changes and installer tracking in the database.

For security purposes the installer datasource could be closed after the context has bootstrapped.  This is the responsibilty
of the application configuration and be aware that some functionality related to querying the installer repository will
not be available if the installer datasource goes offline.

=== Ordering beans
In an Across based application, the primary order of bean interaction should be defined by the module dependencies.
When scanning for beans in all modules (eg. when using a `RefreshableRegistry` or `@RefreshableCollection`), the beans
will be returned according to the module order: beans from earlier bootstrapped modules will be before beans from later modules.
The reasoning is simple: _if I depend on module A, i can rely on module A having done its things before I will_.
If you need more sophisticated ordering, there are two extension points to the default behavior:

.Order annotation and Ordered interface
Core Spring classes.  If you define these on beans, these will take precedence over the order of the modules themselves.
The `Ordered` interface takes precedence over an `@Order` annotation, if both are present.
Using global ordering should be avoided as much as possible, but using for example `Ordered.LOWEST_PRECEDENCE` you can
ensure that a bean comes after all other context created beans in the list.

.OrderInModule annotation and OrderedInModule interface
The equivalent of `@Order` and `Ordered`, but they only apply within a single module.
Use these if you have multiple beans (eg security configurers) of the same type in a single module, and it is important they follow a sequence.

NOTE: Unless a specific order is given either through the interface or annotation, a default order of `Ordered.LOWEST_PRECEDENCE - 1000` is applied.
This way you can still force beans to be ordered behind beans without an explicit order.

WARNING: The current version of Across does not apply the module order hierarchy to event handlers. If event handlers need an order, it should be defined explicitly and you cannot rely that event handlers from other modules you depend on will have been executed before you. This is an important work in progress for one of the next versions of Across.

=== Message sources
Across has its own custom behavior in relation to *messageSource* beans declared in modules.
Each module can declare a default `MessageSource` bean named *messageSource*.  Upon bootstrap this message source will
be added to a hierarchy along with all other *messageSource* beans.  Once bootstrap is complete, a message will be looked
up in all sources defined.

.Default message source hierarchy
By default Across uses the following approach to build a message source hierarchy:

* a *messageSource* bean from a parent `ApplicationContext` is considered to be application specific and should allow
customizing the messages of the modules
* a *messageSource* bean in a module is expected to be able to customize messages from other modules that the current
module depends on
** this is also interpreted as: the message source of a module takes precedence over the message source of earlier modules

As a result, once a context is fully bootstrapped and a message is requested, the sources are queried in the following order:

. message sources of the parent `ApplicationContext` (and up its hierarchy if more than one parent)
. message sources of the modules in reverse bootstrap order (last bootstrapped first)

WARNING: Once an `AcrossContext` is fully bootstrapped, messages will be looked up in the hierarchy built from all
bootstrapped modules.  During the bootstrap phase however, only message sources from earlier modules and the parent
`ApplicationContext` are available.

.Reverting to default spring behavior
Default Spring behavior with message sources is that a `MessageSource` in an `ApplicationContext` will get the
`MessageSource` of the parent `ApplicationContext` as its parent.  In a module setup, this would mean that a message
would first be looked up in the source of the module, and only afterwards in the source of the context.
You can force the default behavior to apply by annotating a *messageSource* bean with `@Internal`.
Note that in that case the *messageSource* will remain internal to the module where it's declared.

.Message source conventions
You can configure a default *messageSource* in a module by simply instantiating an `AcrossModuleMessageSource` bean with that name.
If no `basenames` are specified, this message source will look for a properties file using `classpath:/messages/MODULE_RESOURCES/MODULE_NAME`.

`AcrossModuleMessageSource` is a special case of Spring's `ReloadableResourceBundleMessageSource`.  If development mode is active
and the development locations for the module have been configured, the classpath lookups are replaced by physical file lookups with
a cache time of 1 second.  This is very useful during development where updates to resource bundles can be instantly visible.

.Configuring a default message source for a module
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Configuration
public class ModuleConfig
{
	@Bean
	public MessageSource messageSource() {
		return new AcrossModuleMessageSource();
	}
}
----

=== AcrossContext and ConversionService
An AcrossContext requires a valid `ConversionService` bean named *conversionService* to be present.  If there is none,
a `DefaultFormattingConversionService` will be created and exposed.  If you want to manage the `ConversionService` yourself,
simply create a `ConversionService` with the right name in the parent `ApplicationContext`.

The default *conversionService* will also be attached to the `ApplicationContext` environment of every module.  This
means property fetching using `Environment.getProperty()` methods will perform type conversion using the `ConversionService`
(eg. useful for date property parsing).

.Date conversion
Apart from the `ConversionService` itself, an `AcrossContext` creates a default `StringToDateConverter` bean named *defaultDateConverter*.
This converter supports converting a string to a corresponding date in many common date patterns.  The `StringToDateConverter` assumes a
fixed locale that can be configured (default: `US`).

WARNING: If you manage the `ConversionService` outside of the `AcrossContext` the default `StringToDateConverter` will not
be registered either.