[[across-core]]
= II. Across Core

Across Core is the main dependency that is required for bootstrapping an `AcrossContext`.

[discrete]
== Artifact
[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>com.foreach.across</groupId>
			<artifactId>across-core</artifactId>
			<version>{across-version}</version>
		</dependency>
	</dependencies>
----

== Configuring an AcrossContext

[[enableacrosscontext]]
=== @EnableAcrossContext
Usually your application will consist of a single `AcrossContext` that is configured in the main Spring `ApplicationContext`.
You can enable the automatic creation of an `AcrossContext` by putting the `@EnableAcrossContext` on any `@Configuration` class.
This will initialize a new `AcrossContext` with the main `ApplicationContext` as parent, look for a <<across-datasource,default datasource bean>> named *acrossDataSource* and then configure modules based on the `@EnableAcrossContext` attribute values.

==== AcrossContext autoconfiguration
By default autoconfiguration of the `AcrossContext` will be enabled.
This implies that all `AcrossModule` beans from the parent `ApplicationContext` will be configured, along with any modules specified by name on `@EnableAcrossContext`.

When autoconfiguration is enabled, packages will be scanned to find valid module classes.
Unless packages are configured manually using the *modulePackages* or *modulePackageClasses* attributes, the _com.foreach.across.modules_ package along with the package of the declaring `@Configuration` class will be scanned.

WARNING: If you use `@EnableAcrossContext` on a top-level class (no package specified), package _modules_ and _com.foreach.across.modules_ will be used for default scanning.

Scanning for modules in itself does not add any modules to the `AcrossContext`.
It simply maps all modules that could be autoconfigured on their unique name.
For a module to be autoconfigurable it should adhere to certain conventions, see the section on <<creating-an-acrossmodule,creating an Across module>> for more details.

NOTE: The module scanning packages and settings can be controlled through attributes on `@EnableAcrossContext`.

WARNING: A module name should be unique.
If you have more than one module with the same name, the last module scanned will take precedence.

.Minimal example of using @EnableAcrossContext
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
/**
 * Minimal configuration that will attempt to resolve module MyCustomModule:
 * - in the standard modules package (com.foreach.across.modules)
 * - in the package that AppConfiguration belongs to
 *
 * If found, MyCustomModule and its required dependencies will be added to the AcrossContext.
 * If not found, AcrossContext bootstrapping will fail.
 */
@Configuration
@EnableAcrossContext( "MyCustomModule" )
public class AppConfiguration
{
}
----

If you want to customize the module configuration or a module is not autoconfigurable, you can add it as a bean in the parent `ApplicationContext` instead.

.Example adding a module as a bean
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
/**
 * AcrossWebModule is added to the AcrossContext by name.
 *
 * MyCustomModule is added as a bean in the ApplicationContext.
 * Because the bean implements AcrossModule, it will also be added to the AcrossContext.
 *
 * All required dependencies of either module will also be added if they can be found through scanning.
 */
@Configuration
@EnableAcrossContext( AcrossWebModule.NAME )
public class AppConfiguration
{
    @Bean
    public MyCustomModule myCustomModule() {
        return new MyCustomModule();
    }
}
----

As the previous example shows, you can safely combine beans and named module configuration.
Modules are configured in a certain order:

. Modules defined by name on `@EnableAcrossContext`
. Module beans detected in the `ApplicationContext`
. Modules added through <<acrosscontextconfigurer,`AcrossContextConfigurer` instances>>
. Missing module dependencies resolved during bootstrap

If a module with the same name gets added more than once, the last version added will always win.

[[acrosscontextconfigurer]]
==== Customizing the AcrossContext
After initial configuration but before bootstrapping, the configured `AcrossContext` will be delegated to all `AcrossContextConfigurer` beans it can find in the `ApplicationContext`.
This allows for changing any settings before the actual bootstrap happens.

.Example customizing an AcrossContext
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Configuration
@EnableAcrossContext
public class WebConfiguration implements AcrossContextConfigurer
{
	@Bean
	public DataSource acrossDataSource() {
		BasicDataSource dataSource = new BasicDataSource();
		dataSource.setDriverClassName( "org.hsqldb.jdbc.JDBCDriver" );
		dataSource.setUrl( "jdbc:hsqldb:mem:/hsql/testDataSource" );
		dataSource.setUsername( "sa" );
		dataSource.setPassword( "" );

		return dataSource;
	}

	@Override
	public void configure( AcrossContext context ) {
		context.setDevelopmentMode( true );

		context.addModule( new SomeModule() );
	}
}
----

[discrete]
=== Manual configuration
An `AcrossContext` can be also configured manually and is started using the `bootstrap()` method, and stopped using `shutdown()`.
These methods take care of the Spring `ApplicationContext` lifecycle of all modules configured in the context.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
AcrossContext context = new AcrossContext();
context.setParentApplicationContext( optionalParentContext );
context.setDataSource( someDataSource );
context.addModule( new SomeModule() );

// Start the context
context.bootstrap();

// Stop the context
context.shutdown();
----

== Module configuration
Apart from module settings, an application can also define a number of `<<moduleconfiguration,@ModuleConfiguration>>` classes to be added to the bootstrapping modules.
When using the `@EnableAcrossContext`, the packages to scan for these can be set using attributes, but by default the sub-packages *config* and *extensions* of the importing class will be used.

Alternatively the packages to scan can be controlled via the `moduleConfigurationScanPackages` property on `AcrossContext`.

[[across-bootstrap-order]]
== Across Bootstrap order

order modules based on dependencies
run installers in the different phases
publish events

prepareForBootstrap
AcrossBootstrapConfig / ModuleBootstrapConfig
extendModule
AcrossContextInfo and AcrossModuleInfo - modifying bootstrap configuration from within a module

== Properties
Both AcrossModule and AcrossContext have a collection of Properties.
These can be accessed directly from the instance, but will also be registered as `PropertySource` in the bootstrapping `ApplicationContext`.
Across favours the PropertySource/Environment approach over the concept of multiple PropertyPlaceholderConfigurer.
Reasoning behind this is https://jira.spring.io/browse/SPR-8539?focusedCommentId=75569&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-75569[explained here as a comment on a Spring issue].

[discrete]
=== Registering additional PropertySources
Apart from the Properties directly on AcrossModule and AcrossContext instances, there are methods to register additional PropertySources to a module or context.
PropertySources or properties configured on a module, will only be available within that module; whereas PropertySources or properties on the context will be available in all modules.
Because PropertySource is most often based on an actual Resource file, the addPropertySources() methods allow direct usage of Resource instances.
If the Resource does not exist, it is simply ignored.

[discrete]
=== PropertySource priority
Within the context or module, the order in which PropertySources have been registered determines the order of looking for the property values.
In a context/module hierarchy, the following order is used:

. properties set directly on the current AcrossModule
. PropertySources attached to the current AcrossModule (last one added first)
. properties set directly on the AcrossContext
. PropertySources attached to the AcrossContext (last one added first)
. PropertySources registered in the parent ApplicationContext

[discrete]
=== Accessing properties in modules
Accessing properties in modules is no different than in standard Spring.
By default all properties can be accessed using the Environment.

.Example using Environment
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Configuration
public class Config
{
    @Bean
    public AcrossContext acrossContext( ConfigurableApplicationContext applicationContext ) throws Exception {
        AcrossContext context = new AcrossContext( applicationContext );
        context.setDataSource( acrossDataSource() );
        context.setAllowInstallers( true );

        // Configure some properties
        context.setProperty( "directProperty", 789 );
        context.addPropertySources( new ClassPathResource("my.properties") );

        context.addModule( testModule1() );
        context.addModule( testModule2() );
        return context;
    }
}

@Configuration
public class ConfigInModule{
    @Autowired
    private Environment environment;

    @Bean
    public MyBean myBean() {
        return new MyBean( environment.getProperty( "my.property" ) );
    }
}
----

If you want to use placeholders you must add a PropertySourcesPlaceholderConfigurer to every module where you want placeholders to be resolved.
Because of the way BeanFactoryPostProcessors and PropertyPlaceholderConfigurers work, it is best to configure a new instance in every module, instead of passing a shared postprocessor to all modules.
A default ApplicationContextConfigurer is available in the PropertyPlaceholderSupportConfigurer class.
In practice however: it should be the responsibility of the module to configure a PropertyPlaceholderConfigurer if it uses placeholders!

.Example using PropertySources and simple property placeholder resolving
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Configuration
public class Config
{
    @Bean
    public AcrossContext acrossContext( ConfigurableApplicationContext applicationContext ) throws Exception {
        AcrossContext context = new AcrossContext( applicationContext );
        context.setDataSource( acrossDataSource() );
        context.setAllowInstallers( true );

        // Configure some properties
        context.setProperty( "directProperty", 789 );
        context.addPropertySources( new ClassPathResource("my.properties") );

        // Register the property placeholder resolving in every module
        context.addApplicationContextConfigurer( new PropertyPlaceholderSupportConfigurer(),
                                                 ConfigurerScope.CONTEXT_AND_MODULES );

        context.addModule( testModule1() );
        context.addModule( testModule2() );
        return context;
    }
}

@Configuration
public class ConfigInModule {
    @Bean
    public MyBean myBean( @Value("${my.property}") String myProperty ) {
        return new MyBean( environment.getProperty( myProperty  ) );
    }
}
----

.Example using custom property placeholder resolving
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
// Import inner class to make resolver available both in parent as in Across context
@Configuration
@Import(CustomPropertyConfig.class)
public class Config
{
    @Configuration
    public static class CustomPropertyConfig
    {
        @Bean
        public static PropertySourcesPlaceholderConfigurer properties() {
            PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer();
            configurer.setLocation( new ClassPathResource( "my.properties" ) );
            return configurer;
        }
    }

    @Bean
    public AcrossContext acrossContext( ConfigurableApplicationContext applicationContext ) throws Exception {
        AcrossContext context = new AcrossContext( applicationContext );
        context.setDataSource( acrossDataSource() );
        context.setAllowInstallers( true );

        // Register the property placeholder resolving in every module
        context.addApplicationContextConfigurer( new AnnotatedClassConfigurer( CustomPropertyConfig.class ),
                                                 ConfigurerScope.CONTEXT_AND_MODULES );


        context.addModule( testModule1() );
        context.addModule( testModule2() );
        return context;
    }
}

@Component
public class SomeBeanInModule {
    @Value("${my.property}")
    private String someValueFromProperty;
}
----

[[across-datasource]]
== Across datasource
An AcrossContext supports the configuration of a DataSource instance.
The datasource will be available for all modules as bean named *acrossDataSource*.
Additionally a second datasource can be configured that will be available as the *acrossInstallerDataSource*.
If no separate installer datasource is specified, the default across datasource will be used.

TODO: if you want to run installers, you need a datasource (distributedlock repository, installer tracking)

== Events
Every Across context creates an AcrossEventPublisher bean.
This bean can be wired in any module to dispatch events.
The default implementation of the event publisher uses MBassador.

[discrete]
=== Publishing events
Publishing an event can be done from anywhere by simply creating an instance of the AcrossEvent interface.
This is a marker interface not defining any additional methods.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
public static class SomeEvent implements AcrossEvent {
}

@Autowired
private AcrossEventPublisher eventBus;

public void sendEvent() {
  eventBus.publish( new SomeEvent() );
}
----

[discrete]
=== Subscribing to events
Event handlers must not implement any special interface, event handler methods must declare themselves as handling an event by specifying the @Event annotation.
A single event handler bean can have many handler methods, all event handler beans must be added to the AcrossEventPublisher however.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Autowired
private AcrossEventPublisher eventBus;

@PostConstruct
public void listen() {
    // Subscribe ourselves to the event bus
    eventBus.subscribe( this );
}

@Event
public void handle( SomeEvent event ) {
    // Called whenever an event of type SomeEvent is published
}
----

[discrete]
=== Auto-detecting event handlers
Some beans are automatically scanned for handler methods, these are all beans annotated with @Controller or @AcrossEventHandler.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Component
@AcrossEventHandler
public class MyHandler {
    @Event
    public void handle( SomeEvent event ) {
        // Called whenever an event of type SomeEvent is published
    }
}
----

WARNING: Take special care when combining AOP with event handlers, as the event publisher only has limited support for AOP proxies.
Depending on the strategy used (CGlib or JDK proxy) the actual proxy (CGlib) or the proxy target (in case of JDK proxy) will be registered as the event handler.
In the latter case the event will still be fired but the actual handle method will not be intercepted.

[discrete]
=== Filtering events
Depending on the interface an event implements a handler can be specific about which events it wants to receive.

|===
|Event implements |Filtering

|AcrossEvent
|Is only done on the class of the event. All instances of the specific event class (or subclasses) will be handled.

|NamedAcrossEvent
|Is done on the class of the event as well as the name of the event if an @EventName annotation is present on the handler method.
WARNING: If the handler method defines an @EventName only events matching one of the names and implementing NamedAcrossEvent will be handled.

|ParameterizedAcrossEvent
|Is done on the class of the event as well as on the defined generic parameters.
All instances matching the specific event class and the specific generic class (or subclasses) will be handled.
To support complex generic type filtering, implementations must specify their generic parameters as Spring ResolvableType instances.
Multiple generic parameters as well as nested generics are supported.

|===

Filters can be combined: it is possible to filter an event on both event name and generic parameter.
An event must pass all filters before it is handled.

.Examples of custom events
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----

/**
 * Named events.
 */
class MyNamedEvent implements NamedAcrossEvent {
  @Override
  public String getEventName() {
    return "MyNamedEvent";
  }
}

@Event
public void handle( @EventName({"MyNamedEvent","MyOtherNamedEvent"}) NamedAcrossEvent event ) {
    // do something
}

/**
 * Event with generic parameters.
 */
class MyListEvent<T> implements ParameterizedAcrossEvent {
  private final ResolvableType[] genericTypes;


  public MyListEvent( Class memberClass ) {
    genericTypes = new ResolvableType[] {
      ResolvableType.forClassWithGenerics( List.class, memberClass )
    };
  }


  @Override
  public ResolvableType[] getEventGenericTypes() {
    return genericTypes;
  }
}

@Event
public void handle( MyListEvent<List<Integer>> event ) {
  // would match against: new MyListEvent<List<Integer>>( Integer.class );
}
----

[discrete]
=== Advanced event filtering and asynchronous event handling
Because the default implementation uses the MBassador messaging bus, it is possible to create custom filters and configure handlers or listeners to work asynchronously.
Please refer to the MBassador documentation on how to do this.

[discrete]
=== Bootstrap events
The following bootstrap events are being published by the AcrossContext:

AcrossModuleBeforeBootstrapEvent::
Sent for each module, right before the bootstrapping of that module starts.
This is the very last point in time in which the ModuleBootstrapConfig can still be modified.

AcrossModuleBootstrappedEvent::
Sent for each module, right after the module has bootstrapped.

AcrossContextBootstrappedEvent::
Sent once for every AcrossContext, after the entire bootstrap phase has finished.

[discrete]
=== Exceptions in events
When dispatching an event through its handlers, each handler is executed in isolation from the others.
Events do not bubble up to the publisher.
This means if an exception occurs within a handler, that will not impact the original publisher in anyway and the next handler will simply execute.
However, when an exception occurs that is not handled within the handler method, a new PublicationError message is publishes that can be picked up with a custom IPublicationErrorHandler implementation added to the underlying MBassadorEventPublisher using addErrorHandler().
By default all exceptions will be logged in the AcrossEventPublisher logger.
There is no defined order in which an event is sent to the handlers.
Your event handlers should not depend on other event handlers having run.
WARNING: Ordering event handlers is currently not supported, issue #21 on the backlog hopes to resolve this in a future release.

== Refreshable beans
Refreshable and PostRefresh annotations TODO
postrefresh is always called

=== RefreshableRegistry
A RefreshableRegistry is a collection of beans of a specified class that updates itself on every context refresh.  A RefreshableRegistry can also scan for beans inside the other modules in the running context, without the need for those beans to be exposed.  This allows other modules to pick up extensions or configurations from other modules that bootstrap later, and update its configuration on the context bootstrapped event.
The members of a RefreshableRegistry are also ordered according to the Across module order hierarchy (see section Ordering beans).

== Ordering beans
In an Across based application, the primary order of bean interaction should be defined by the module dependencies.
When scanning for beans in all modules (eg. when using a `RefreshableRegistry` or `@RefreshableCollection`), the beans will be returned according to the module order: beans from earlier bootstrapped modules will be before beans from later modules.
The reasoning is simple: _if I depend on module A, i can rely on module A having done its things before I will_.
If you need more sophisticated ordering, there are two extension points to the default behavior:

.Order annotation and Ordered interface
Core Spring classes.
If you define these on beans, these will take precedence over the order of the modules themselves.
The `Ordered` interface takes precedence over an `@Order` annotation, if both are present.
Using global ordering should be avoided as much as possible, but using for example `Ordered.LOWEST_PRECEDENCE` you can ensure that a bean comes after all other context created beans in the list.

.OrderInModule annotation and OrderedInModule interface
The equivalent of `@Order` and `Ordered`, but they only apply within a single module.
Use these if you have multiple beans (eg security configurers) of the same type in a single module, and it is important they follow a sequence.

NOTE: Unless a specific order is given either through the interface or annotation, a default order of `Ordered.LOWEST_PRECEDENCE - 1000` is applied.
This way you can still force beans to be ordered behind beans without an explicit order.

WARNING: The current version of Across does not apply the module order hierarchy to event handlers.
If event handlers need an order, it should be defined explicitly and you cannot rely that event handlers from other modules you depend on will have been executed before you.
This is an important work in progress for one of the next versions of Across.

[[development-mode]]
== Development mode
The AcrossContext can have development mode enabled through the *developmentMode* property.
Modules can use development mode to configure different services (or services differently).
An example is auto-reloading and no caching of the message sources if development mode is active.

Apart from setting the *developmentMode* property on `AcrossContext`, development mode can be activated the following way:

. property *across.development.active* is _true_
. Spring profile *dev* is active

== Default beans
=== AcrossContextInfo

=== ConversionService
An AcrossContext requires a valid `ConversionService` bean named *conversionService* to be present.
If there is none, a `DefaultFormattingConversionService` will be created and exposed.
If you want to manage the `ConversionService` yourself, simply create a `ConversionService` with the right name in the parent `ApplicationContext`.

The default *conversionService* will also be attached to the `ApplicationContext` environment of every module.
This means property fetching using `Environment.getProperty()` methods will perform type conversion using the `ConversionService` (eg. useful for date property parsing).

.Date conversion
Apart from the `ConversionService` itself, an `AcrossContext` creates a default `StringToDateConverter` bean named *defaultDateConverter*.
This converter supports converting a string to a corresponding date in many common date patterns.
The `StringToDateConverter` assumes a fixed locale that can be configured (default: `US`).

WARNING: If you manage the `ConversionService` outside of the `AcrossContext` the default `StringToDateConverter` will not be registered either.

=== DistributedLockRepository
tbd

=== AcrossDevelopmentMode
Utility bean that can be used to verify if <<development-mode,development mode>> is active, and to get development locations for resources files.

== Developing modules

[[creating-an-acrossmodule]]
=== Creating an AcrossModule
Creating a new Across module is done by extending `AcrossModule` and providing a valid name and description.
An `AcrossModule` is in essence a configuration class.
It uniquely identifies the module and holds all configuration parameters required to bootstrap the module.
It also allows you to alter settings of how beans should be shared with other modules.

A module name should be unique and as a best practice also be available as a public static final *NAME* field on the `AcrossModule` implementation.

.Minimal AcrossModule
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
public class ValidModule extends AcrossModule
{
	public static final String NAME = "ValidModule";

	@Override
	public String getName() {
		return NAME;
	}

	@Override
	public String getDescription() {
		return "ValidModule exposes some valid beans.";
	}
}
----

.Making an AcrossModule autoconfigurable
For an Across module to be autoconfigurable it must adhere to the following conventions:

* the module name must be available in the public static final *NAME* field
* the module must have public constructor without any parameters

.Definining beans
Upon bootstrap a module will create its own `ApplicationContext` with the `AcrossContext` as parent.
The beans created in the module `ApplicationContext` are configured using `ApplicationContextConfigurer` instances.

By default a scan for `@Configuration` classes will happen on the *config* package below the package of the `AcrossModule` implementation.
If you want more explicit control, you can override the `registerDefaultApplicationContextConfigurers()` method.

.Module resources
Most modules will also define one or more resources in a location determined on the _resources key_ of the module.
By default the resources key or a module is the same as the module name.
You can change this by overriding the `getResourcesKey()` method.

=== Module settings

=== Module dependencies

There are several ways to influence the beans that are being bootstrapped with a module, by passing information from the configuration to the actual module ApplicationContext.

==== AcrossDepends

[discrete]
===== Using AcrossDepends on a module

Using AcrossDepends annotation on a component class you can avoid beans or Configurations from being created based on the presence of other modules.
required modules: the component will only be created if all required modules are present
optional modules: the component will only be created if at least one of the optional modules is present

[discrete]
===== Using AcrossDepends on component classes
expression will be evaluated against the module context - as usual - beans from earlier modules will be available

==== AcrossCondition
AcrossCondition is another implementation of Spring Conditional.
AcrossCondition takes one or more Spring Expression Language (SpEL) statements as value, and all statements must evaluate to true before the component will be created.
It can be used to check environment or module properties (or any property on already existing beans from the parent context).
The current module instance can always be referenced under the key currentModule in the expression.

.Examples using AcrossCondition
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Configuration
@AcrossCondition("#{currentModule.transactionEnabled}")
public class EnableTransactionConfiguration {
    // Only executed if the property isTransactionEnabled() on the AcrossModule instance is true
}

@Controller
@AcrossCondition("${mymodule.testcontroller:true}")
public class MyTestController {
    // The controller would only be created based on the property 'mymodule.testcontroller' in the Environment of the bootstrapping module
    // If the Environment does not contain the property, value 'true' will be used
}
----

==== Module roles
infrastructure modules

=== Bootstrap interaction

[[moduleconfiguration]]
==== @ModuleConfiguration
Any module can provide a number of classes annotated with `@ModuleConfiguration`.
These classes are just like classes annotated with `@Configuration`, except they will not be added to the `ApplicationContext` of the current module, but to the ones of the modules specified in the annotation attributes.

`@ModuleConfiguration` serves as a replacement for `@Configuration`.
All other bean related annotations like conditionals should also work on `@ModuleConfiguration` classes.
Keep in mind however that the actual creation of the beans (and evaluation of conditionals) will happen in the `ApplicationContext` to which the configuration is added, and not necessarily the one of the module defining the class.

.Example of using @ModuleConfiguration
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@ModuleConfiguration(SpringSecurityModule.NAME)
public class SecurityConfiguration
{
	@Autowired
	public void configureGlobal( AuthenticationManagerBuilder auth ) throws Exception {
		auth.inMemoryAuthentication()
		    .withUser( "admin" ).password( "admin" )
		    .authorities( new NamedGrantedAuthority( "access administration" ) );
	}
}
----

WARNING: When not specifying any module on a `@ModuleConfiguration`, the configuration will be added to all modules, including the module defining the class.

.Scanning for `@ModuleConfiguration` classes
By default the sub-packages *config* and *extensions* of an `AcrossModule` will be scanned to detect classes annotated with `@ModuleConfiguration`.
A module can configure these packages by overriding the `getModuleConfigurationScanPackages()` method.

==== Subscribe to events

==== prepareForBootstrap
A third approach for customizing module configuration is implementing prepareForBootstrap() on the AcrossModule.
This is the last point in time were any module can modify the bootstrap configuration of any other module (adding configurers, modifying expose filter etc).

todo: ModuleConfigurationSet

.Example of a prepareForBootstrap
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
    @Override
    public void prepareForBootstrap( ModuleBootstrapConfig currentModule, AcrossBootstrapConfig contextConfig ) {
        if ( ArrayUtils.contains( supportedViews, AcrossWebViewSupport.JSP ) ) {
            currentModule.addApplicationContextConfigurer(
                    new AnnotatedClassConfigurer( JstlViewSupportConfiguration.class ) );
        }
        if ( ArrayUtils.contains( supportedViews, AcrossWebViewSupport.THYMELEAF ) ) {
            currentModule.addApplicationContextConfigurer(
                    new AnnotatedClassConfigurer( ThymeleafViewSupportConfiguration.class ) );
        }
    }
----

=== Exposing beans
A module can share its beans with other modules by *exposing* them.
All exposed beans from a module are pushed upwards into the parent `ApplicationContext` of the `AcrossContext` itself.
Likewise, at the end of the context bootstrap, all exposed beans are pushed into the `ApplicationContext` that is - optionally - configured as the parent of the `AcrossContext`.

Which beans are exposed is determined by the `exposeFilter` property on an `AcrossModule`.
By default all beans annotated with `@Exposed` or `@Service` will be exposed.
See the `com.foreach.across.core.filters.BeanFilter` implementations for standard filters.

When pushing beans to the parent `ApplicationContext` it is possible to run into name conflicts or duplicate bean types.
You can use an `ExposedBeanDefinitionTransformer` to modify the bean definitions that are pushed to the parent.
Common examples for this are changing the bean names or marking the beans as primary.
You can set the transformer to use through the `exposeTransformer` property on an `AcrossModule` or the `AcrossContext`.

ExposedBeanDefinitionTransformer on AcrossModule:: will be applied when pushing beans from the module into the `AcrossContext`
ExposedBeanDefinitionTransformer on AcrossModule:: will be applied when pushing beans from the `AcrossContext` into the parent `ApplicationContext`

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
public class SomeModule extends AcrossModule
{
	/**
	 * Only expose specific beans from this module and ensure that
	 * they have a prefixed bean name for the other modules.
	 */
	public SomeModule() {
		setExposeFilter( new ClassBeanFilter( PlatformTransactionManager.class, SessionFactory.class ) );
		setExposeTransformer( new BeanPrefixingTransformer( "someModule" ) );
	}
}
----

Beans created directly in the `AcrossContext` scope - and not inside one of the modules - will only be exposed if they are annotated explicitly with `@Exposed`.
The `AcrossContext` does not support a custom `exposeFilter` but you can supply an additional `exposeTransformer` on the context level.
If you want to avoid an `AcrossContext` to push the exposed beans further upwards into its parent `ApplicationContext`, you should configure the `ExposedBeanDefinitionTransformer.REMOVE_ALL` as `exposeTransformer` on the `AcrossContext` itself.
For an `AcrossModule` using the `REMOVE_ALL` transformer would be the same as putting `null` as `exposeFilter`.

.Manually exposing beans
In addition to setting the _exposeFilter_ property, `AcrossModule` has `expose(...)` methods that allow you to quickly expose one or more beans based on bean name or type.

=== Message sources

[[auto-detecting-message-sources]]
==== Auto-detecting message sources
If a module has a message source packaged in the right location it will be auto-detected and configured.
The following default message properties will be configured automatically if they are present on the classpath:

* /messages/MODULE_RESOURCES/MODULE_NAME.properties _(deprecated)_
* /messages/MODULE_RESOURCES/default.properties
* /messages/MODULE_RESOURCES/default/*.properties

The default message sources are configured using an instance of `AcrossModuleMessageSource`.
`AcrossModuleMessageSource` is a special case of Spring's `ReloadableResourceBundleMessageSource`.
If development mode is active and the development locations for the module have been configured, the classpath lookups are replaced by physical file lookups with a cache time of 1 second.
This is very useful during development where updates to resource bundles can be instantly visible.

Automatic configuration of message sources only happens if the module does not define a bean named *messageSource*.
The following section details how you can manually define message sources.

==== Message source hierarchy
Across has its own custom behavior in relation to *messageSource* beans declared in modules.
Each module can declare a default `MessageSource` bean named *messageSource*.
Upon bootstrap this message source will be added to a hierarchy along with all other *messageSource* beans.
Once bootstrap is complete, a message will be looked up in all sources defined.

.Default message source hierarchy
By default Across uses the following approach to build a message source hierarchy:

* a *messageSource* bean from a parent `ApplicationContext` is considered to be application specific and should allow
customizing the messages of the modules
* a *messageSource* bean in a module is expected to be able to customize messages from other modules that the current
module depends on
** this is also interpreted as: the message source of a module takes precedence over the message source of earlier modules

As a result, once a context is fully bootstrapped and a message is requested, the sources are queried in the following order:

. message sources of the parent `ApplicationContext` (and up its hierarchy if more than one parent)
. message sources of the modules in reverse bootstrap order (last bootstrapped first)

WARNING: Once an `AcrossContext` is fully bootstrapped, messages will be looked up in the hierarchy built from all bootstrapped modules.
During the bootstrap phase however, only message sources from earlier modules and the parent `ApplicationContext` are available.

.Reverting to default spring behavior
Default Spring behavior with message sources is that a `MessageSource` in an `ApplicationContext` will get the `MessageSource` of the parent `ApplicationContext` as its parent.
In a module setup, this would mean that a message would first be looked up in the source of the module, and only afterwards in the source of the context.
You can force the default behavior to apply by annotating a *messageSource* bean with `@Internal`.
Note that in that case the *messageSource* will remain internal to the module where it's declared.

.Configuring a custom message source for a module with development mode support
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Configuration
public class ModuleConfig
{
	@Bean
	public MessageSource messageSource() {
        AcrossModuleMessageSource source = new AcrossModuleMessageSource();
        source.setBasenames( "classpath:/my/module/messages );

        return source;
	}
}
----

=== Installers
A module can have one or more installer classes.
The purpose of installers is setup data that modules need, before the actual application takes over.
Examples: creating database schema, installing default or test data...

An `@Installer` annotation marks a class as an installer and allows you to specify the important installer attributes.

|===
|attribute |description

|*name*
|Optional (unique) name of the installer.
If not specified, the fully qualified class name of the installer class will be used.

|*description*
|Descriptive text of what will be installed.

|*phase*
|When this installer should run during the context bootstrap.
See <<installer-bootstrap-phases,bootstrap phases>>.

|*runCondition*
|Condition when this installer should run.  See <<installer-run-conditions,run conditions>>.

|*version*
|Version number of the installer.
This value should be incremented to enforce a new run of the same installer.
Only relevant if the run condition is `VersionDifferent`.

|===

==== Installer detection
By default installers are detected from the classpath by scanning the *installers* package relative to the package of the `AcrossModule`.
Changing the packages to scan for installers can be done by overriding the `getInstallerScanPackages()` method on `AcrossModule`.

NOTE:  If you manually want to specify a list of installers, you can do so by overriding the `getInstallers()` method.
Though still possible for compatibility reasons, installers should be specified with their `Class`.

==== Installer tracking and synchronization
The execution of installers is tracked using the `AcrossInstallerRepository`.
This allows for installers to execute only if they have not yet been executed (see <<installer-run-conditions,run conditions>>).

In addition, installer execution is synchronized for multiple applications connecting on the same database.
This is done through the `DistributedLockRepository` that is created in the core schema.
A lock will be taken on the datasource as soon as a single installer wishes to execute, and will only be released once bootstrapping is fully done.

Because of tracking and synchronization, a <<installer-datasource,datasource>> is required in order to execute installers.

NOTE: The `AcrossInstallerRepository` can be wired as a bean in installers.
This can be helpful in migration trajectories for example to rename installers.

[[installer-bootstrap-phases]]
==== Bootstrap phases
Installers are executed during a specific phase of the context bootstrap.
This phase should be specified for every installer.
The phase will determine which beans are available in the installer.

The following bootstrap phases exist:

BeforeContextBootstrap::
The installer is executed before any of the modules in the AcrossContext are bootstrapped.
Only beans from the parent `ApplicationContext` or the <<installer-applicationcontext,installer `ApplicationContext`>> are available.

BeforeModuleBootstrap::
The installer is executed before the module that owns it bootstraps, but after all previous modules have bootstrapped.
All beans from previous modules will also be available to the installer.

AfterModuleBootstrap::
The installer is executed after the module that owns it has bootstrapped, but before the next module bootstraps.
All beans from the current module are available.

AfterContextBootstrap::
The installer is executed after all modules have bootstrapped, but before the `AcrossContextBootstrappedEvent` is published.
All beans from all modules are available.

[[installer-run-conditions]]
==== Run conditions
The following run conditions are supported for an installer:

AlwaysRun::
The installer will always be executed, everytime the module bootstraps.

VersionDifferent::
The installer will only execute if the _version_ attribute is higher than the version previously executed.

In addition to the standard run conditions, you can use <<installer-conditionals, `@Conditional` annotations on installer classes>>.
This includes for example the use of `@AcrossDepends` to execute installers if certain modules are active.

==== Installer group
In addition to the standard `@Installer` attributes, an `@InstallerGroup` annotation can be specified.
This allows grouping types of installers together (for example schema) and overruling their execution using <<installer-settings,`InstallerSettings`>>.

==== Installer execution order
If all conditions are fulfilled, installers will be executed in a predetermined order:

. in <<installer-bootstrap-phases,bootstrap phase>> order
. in <<across-bootstrap-order,module bootstrap order>>
. in installer order (according to `@Order` annotations on the installer class)

WARNING: Installers without an `@Order` annotation behave as if they have an order index of *0*.
In that case the installer registration order will be used as a fallback, with installers specified through `getInstallers()` having a higher precedence.

[[installer-datasource]]
==== Datasources and installers
An `AcrossContext` requires at least one datasource if modules need to run installers.
Certain core features like the `DistributedLockRepository` also require the core schema to be installed and will require a valid datasource to be configured.

The main datasource is available for all modules as a bean named `acrossDataSource`.
Optionally a separate installer datasource can be configured that will be available as `acrossInstallerDataSource`.
If no separate installer datasource is specified, the default across datasource will be used.

IMPORTANT: A valid default datasource is always required for installers to run.
It is not possible to configure only an installer datasource as the distributed locking mechanism uses the default datasource.

The installer datasource is the default datasource used for all `AcrossLiquibaseInstaller` instances.

[[installer-applicationcontext]]
==== Installer ApplicationContext
If installers need to be run for a module, a specific `ApplicationContext` is created in which the installers will be wired as beans.
This `ApplicationContext` can exist before the actual module `ApplicationContext` does.
However, all beans from the parent Across context and the module context - when created - are available in installers.

Installer contexts are temporary, once the Across context has bootstrapped they are closed.
Configuration and other annotated classes can be added to the installer context by using `ApplicationContextConfigurer` implementations, either on the `AcrossContext` or on an `AcrossModule`.

By default, the package *installers.config* relative to the module package will be scanned for beans to be added to the installer `ApplicationContext`.

.Example using different datasource inside the modules
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Configuration
class Config implements AcrossContextConfigurer
{
    /**
     * Installer tracking will be done on this datasource.
     */
    @Bean
    public EmbeddedDatabase acrossDataSource() {
        return new EmbeddedDatabaseBuilder()
                .setType( EmbeddedDatabaseType.HSQL )
                .setName( "core" )
                .build();
    }

    @Bean
    public EmbeddedDatabase moduleDataSource() {
        return new EmbeddedDatabaseBuilder()
                .setType( EmbeddedDatabaseType.HSQL )
                .setName( "data" )
                .build();
    }

    @Override
    public void configure( AcrossContext context ) {
        ProvidedBeansMap beans = new ProvidedBeansMap();
        beans.put( AcrossContext.DATASOURCE, new PrimarySingletonBean( moduleDataSource() ) );
        beans.put( AcrossContext.INSTALLER_DATASOURCE, moduleDataSource() );

        context.addApplicationContextConfigurer( new ProvidedBeansConfigurer( beans ),
                                                 ConfigurerScope.MODULES_ONLY );
        context.addInstallerContextConfigurer( new ProvidedBeansConfigurer( beans ) );
    }
}
----

NOTE: The installer context has no web support as it is a direct implementation of `AcrossApplicationContext` but does not implement `WebApplicationContext`.

[[installer-conditionals]]
Installers are registered as bean definitions in the installer `ApplicationContext`.
You can use any Spring `@Conditional` annotations to suppress installer execution, even if the run conditions are fulfilled.

NOTE: When registering bean definitions to the installer context, a good practice is to demarcate beans as `@Lazy`.
 In that case they will never get created if the installer conditionals fail.

==== AcrossLiquibaseInstaller
Across core comes with an `AcrossLiquibaseInstaller` class.
This is an abstract base class for executing liquibase XML resources.
Simply extending the base class and annotating as installer will execute an XML resource in the same package as the installer class against the installer datasource.

.Example using different datasource inside the modules
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
package my.package;

@Installer(description = "Liquibase installer", runCondition = InstallerRunCondition.AlwaysRun)
public class LiquibaseInstaller extends AcrossLiquibaseInstaller
{
    // Will execute the resource file 'my/package/LiquibaseInstaller.xml'
    // As liquibase has its own locking mechanism (slower than Across!), we can safely always run
}
----

===== SchemaConfiguration
Before installation, an `AcrossLiquibaseInstaller` will try to detect a `SchemaConfiguration` class, which it will use to configure it's default schema.
`SchemaConfiguration` beans can be annotated with the `Module` annotation. If it is not annotated with a `Module` annotation that `SchemaConfiguration` bean
will be considered the default `SchemaConfiguration`.

An `AcrossLiquibaseInstaller` will try to find a `SchemaConfiguration` for it's own module first, failing that it will fall back to the default `SchemaConfiguration`.
If no default or module `SchemaConfiguration` is found, the installer will continue without setting it's default schema.

IMPORTANT: The Configuration class that defines the `SchemaConfiguration` beans should be added by an `AcrossContextConfigurer` by using a `ComponentScanConfigurer`.
Other configurers such as `ProvidedBeansConfigurer` will erase the annotations from the `SchemaConfiguration` bean's factory method.

.Example of a configuration class defining some `SchemaConfiguration` beans
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
package my.package;

@Configuration
public class SchemaConfig implements AcrossContextConfigurer
{

    /**
     * AcrossLiquibaseInstaller in the QuotationModule will automatically pick up this SchemaConfiguration.
     * Liquibase scripts will run with 'MY_QUOTATIONS' as their default schema.
     */
     @Bean
     @Module( "QuotationModule" )
     public SchemaConfiguration userSchemaConfiguration() {
        return new SchemaConfiguration( "MY_QUOTATIONS" );
     }

     /**
      * This is the default SchemaConfiguration.
      * AcrossLiquibaseInstaller in other module will pick up this SchemaConfiguration.
      */
     @Bean
     @Module
     public SchemaConfiguration defaultSchemaConfiguration() {
        return new SchemaConfiguration( "MY_SCHEMA" );
     }

     @Override
     public void configure( AcrossContext context ) {
         context.addApplicationContextConfigurer( new ComponentScanConfigurer( "my.package.SchemaConfig" ) );
     }

}
----

The `SchemaConfiguration` bean's default schema can be overwritten by manually. You will need to extend `AcrossLiquibaseInstaller` and set the default schema
using the `AcrossLiquibaseInstaller`.`setDefaultSchema` method.

.Example schema configuration Using `AcrossLiquibaseInstaller`.`setDefaultSchema`
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
package my.package;

/**
 * Liquibase script of this installer will run with 'IM_SPECIAL' as default schema.
 * Regardless of any defined SchemaConfiguration
 */
@Installer(description = "Liquibase installer", runCondition = InstallerRunCondition.AlwaysRun)
public class SpecialSchemaInstaller extends AcrossLiquibaseInstaller
{
    public SpecialSchemaInstaller() {
        setDefaultSchema( "IM_SPECIAL" );
    }
}
----

[[installer-settings]]
==== InstallerSettings
For advanced configuration, both `AcrossContext` and `AcrossModule` allow `InstallerSettings` to be set.
`InstallerSettings` can be used to set the action (eg. force executed, skip) to be performed for one or more installers
or installer groups.

`InstallerSettings` accepts an `InstallerActionResolver` for determining install action at runtime.
Alternatively an installer can implement `InstallerActionResolver` that will be used in a second stage only if the original action is `EXECUTE`.

Please refer to the javadoc for more information.

=== Module version information
Across modules have version information attached in the form of an `AcrossVersionInfo` property.
This object provides information like the current version and time when it was built.
By default this information is fetched automatically from the *META-INF/MANIFEST.MF* resource.
The following attributes are required for a fully configured `AcrossVersionInfo` instance:

.MANIFEST attributes
|===
|Attribute |Example|Description

|*Implementation-Title*
|across-web
|Name of the project the class (`AcrossModule`) belongs to. Often also the JAR name.

|*Implementation-Version*
|{across-version}
|Build version of the `AcrossModule`.

|*Build-Time*
|20150831-1011
|Timestamp when the version was built (in *yyyyMMdd-HHmm* format).

|===

Using Maven a valid MANIFEST file can automatically be created using the following plugin configuration:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-jar-plugin</artifactId>
        <version>2.6</version>
        <configuration>
            <archive>
                <manifest>
                    <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
                </manifest>
                <manifestEntries>
                    <Build-Time>${maven.build.timestamp}</Build-Time>
                </manifestEntries>
            </archive>
        </configuration>
    </plugin>
----