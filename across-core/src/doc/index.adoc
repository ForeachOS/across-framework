[[across-core]]
== Across core

[discrete]
=== Artifact
[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>across</groupId>
			<artifactId>across-core</artifactId>
			<version>{across-version}</version>
		</dependency>
	</dependencies>
----

=== Dependencies

=== Creating an AcrossContext
==== Manual creation of an AcrossContext
An `AcrossContext` can be configured manually and is started using the `bootstrap()` method, and stopped using `shutdown()`.
These methods take care of the Spring `ApplicationContext` lifecycle of all modules configured in the context.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
AcrossContext context = new AcrossContext();
context.setParentApplicationContext( optionalParentContext );
context.setDataSource( someDataSource );
context.addModule( new SomeModule() );

// Start the context
context.bootstrap();

// Stop the context
context.shutdown();
----

==== Using @EnableAcrossContext and AcrossContextConfigurer
Usually your application will consist of a single `AcrossContext` that is configured in the main Spring `ApplicationContext`.
You can enable the automatic creation of an `AcrossContext` by putting the `@EnableAcrossContext` on any `@Configuration` class.
This will initialize a new `AcrossContext` with the main `ApplicationContext` as parent, look for a default datasource bean named
`acrossDataSource` and then delegate context configuration to all `AcrossContextConfigurer` beans it can find in the `ApplicationContext` before bootstrapping.

The `AcrossContext` will be configured with sensible defaults but all settings can be overridden in any `AcrossContextConfigurer`.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Configuration
@EnableAcrossContext
public class WebConfiguration implements AcrossContextConfigurer
{
	@Bean
	public DataSource acrossDataSource() {
		BasicDataSource dataSource = new BasicDataSource();
		dataSource.setDriverClassName( "org.hsqldb.jdbc.JDBCDriver" );
		dataSource.setUrl( "jdbc:hsqldb:mem:/hsql/testDataSource" );
		dataSource.setUsername( "sa" );
		dataSource.setPassword( "" );

		return dataSource;
	}

	@Override
	public void configure( AcrossContext context ) {
		context.setDevelopmentMode( true );

		context.addModule( new SomeModule() );
	}
}
----

=== Datasources and installers
An `AcrossContext` requires at least one datasource if modules need to run installers.  Certain core features like the
`DistributedLockRepository` also require the core schema to be installed and will require a valid datasource to be configured.

The main datasource is available for all modules as a bean named `acrossDataSource`. Optionally a separate installer datasource
can be configured that will be available as `acrossInstallerDataSource`.  If no separate installer datasource is specified,
the default across datasource will be used.

IMPORTANT: A valid default datasource is always required for installers to run. It is not possible to configure only an installer
datasource as the distributed locking mechanism uses the default datasource.

The installer datasource can be wired anywhere, but will be the default datasource used for all `AcrossLiquibaseInstaller instances.
Its purpose is to provide a separate datasource with augmented permissions to perform schema changes and installer tracking in the database.

For security purposes the installer datasource could be closed after the context has bootstrapped.  This is the responsibilty
of the application configuration and be aware that some functionality related to querying the installer repository will
not be available if the installer datasource goes offline.

=== Ordering beans
In an Across based application, the primary order of bean interaction should be defined by the module dependencies.
When scanning for beans in all modules (eg. when using a `RefreshableRegistry` or `@RefreshableCollection`), the beans
will be returned according to the module order: beans from earlier bootstrapped modules will be before beans from later modules.
The reasoning is simple: _if I depend on module A, i can rely on module A having done its things before I will_.
If you need more sophisticated ordering, there are two extension points to the default behavior:

.Order annotation and Ordered interface
Core Spring classes.  If you define these on beans, these will take precedence over the order of the modules themselves.
The `Ordered` interface takes precedence over an `@Order` annotation, if both are present.
Using global ordering should be avoided as much as possible, but using for example `Ordered.LOWEST_PRECEDENCE` you can
ensure that a bean comes after all other context created beans in the list.

.OrderInModule annotation and OrderedInModule interface
The equivalent of `@Order` and `Ordered`, but they only apply within a single module.
Use these if you have multiple beans (eg security configurers) of the same type in a single module, and it is important they follow a sequence.

NOTE: Unless a specific order is given either through the interface or annotation, a default order of `Ordered.LOWEST_PRECEDENCE - 1000` is applied.
This way you can still force beans to be ordered behind beans without an explicit order.

WARNING: The current version of Across does not apply the module order hierarchy to event handlers. If event handlers need an order, it should be defined explicitly and you cannot rely that event handlers from other modules you depend on will have been executed before you. This is an important work in progress for one of the next versions of Across.