[[across-web]]
= III. Across Web

:module-artifact: across-web
:module-name: AcrossWebModule
:module-url: https://foreach.atlassian.net/wiki/display/AX/Across+web+module
== General information

=== About
{module-name} provides the following infrastructure:

 * a thymeleaf across dialect
 * a menu builder
 * auto configuration of <<multipart-config,Multipart filter>>
 * auto configuration of static resources with <<client-side-caching,client-side caching>> and <<resource-url-versioning,url versioning>>

Module website: {module-url}

=== Artifact
[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>com.foreach.across</groupId>
			<artifactId>across-web</artifactId>
			<version>{across-version}</version>
		</dependency>
	</dependencies>
----

[[across-web-module-settings]]
=== Module settings

All properties start with the *acrossWebModule.* prefix.

|===
|Property |Type |Description |Default

|views.thymeleaf
|`Boolean`
|Should Thymeleaf view support be enabled.
|_true_

|views.jsp
|`Boolean`
|Should JSP/JSTL view support be enabled.
|_false_

|resources.path
|`String`
|Relative path for serving all static resources.
|/across/resources

|resources.folders
|`String[]`
|Default subfolders of _views_ that should be served as static resources.
|js,css,static

|resources.versioning.enabled
|`Boolean`
|Auto configure versioning of the default resource resolvers.
|_true_

|resources.versioning.version
|`String`
|Fixed version if resource versioning is enabled.  Default will use build number or module version.
|_null_

|resources.caching.enabled
|`Boolean`
|Auto configure client-side caching of static resources.
|_true_

|resources.caching.period
|`Integer`
|Period for client-side resource caching (if enabled).  Defaults to 1 year.
|_60*60*24*365_

|templates.enabled
|`Boolean`
|Should support for <<web-templates,web templates>> be enabled.
|_true_

|templates.auto-register
|`Boolean`
|If <<web-templates,web templates>> are enabled, should named templates be autodetected.
|_true_

|multipart.auto-configure
|`Boolean`
|Should a multipart resolver be configured automatically.
|_true_

|multipart.settings
|`MultipartConfigElement`
|Multipart upload settings, if missing defaults will be used.
|_null_

|development-views
|`Map<String,String>`
|Map of physical locations for views resources.  Only used if development mode is active.
|_Collections.emptyMap()_

|===

== AcrossWebModule and ConversionService
AcrossWebModule requires a `FormattingConversionService` bean named *mvcConversionService* to be present.
If there is none, one will be created and exposed.  By default the parent *conversionService* bean will be reused if
it implements the right interface.  If you want to manage the *mvcConversionService* separately, simply create
 a `FormattingConversionService` with the right name in the parent context.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Configuration
public class ManualConversionServiceConfiguration
{
	@Bean(name = AcrossWebModule.CONVERSION_SERVICE_BEAN)
	public FormattingConversionService mvcConversionService() {
	    return new FormattingConversionService();
	}
}
----

The *mvcConversionService* will be passed to all `WebMvcConfigurer` instances in order to add formatters.  It is also
the default `ConversionService` attached to the `WebDataBinder`.

NOTE: There will be at least 2 `ConversionService` beans in the across context when `AcrossWebModule` is enabled:
*conversionService* and *mvcConversionService*.  If you have duplicate bean exceptions due to unqualified autowiring,
you should make one of both primary.

[[across-application]]
== @AcrossApplication
`@AcrossApplication` annotation can be used as an alternative for `@EnableAcrossContext` when defining an application.
In addition to default context configuration options, it adds Spring Boot auto configuration classes for embedded servlet containers and enables dynamic modules.

=== Embedded servlet container
Using `@AcrossApplication` adds the necessary Spring Boot auto configuration classes for embedded servlet containers.
If you have for example *spring-boot-starter-tomcat* on the classpath, you can run an Across based application inside an embedded Tomcat using `SpringApplication`.

.Minimal example of a Spring Boot based Across application
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@AcrossApplication(modules = { MyModule.NAME, MyOtherModule.NAME })
public class MyApplication
{
	public static void main( String[] args ) {
		SpringApplication.run( MyApplication.class, args );
	}
}
----

=== Dynamic Across modules
Using `@AcrossApplication` on a class will automatically enable dynamic Across modules on that class.
Before bootstrapping the context, the configurator will attempt to find an application specific infrastructure, application or postprocessor module.
The name of the expected module is generated based on the name of the importing class.
If no module with that name can be resolved, the configurator will see if a child package is present relative to the package of the importing class.
Depending on the child package name, a dynamic module will be generated.

|===
|||

|*Importing class*
|MyApplication
|MyConfiguration

|*Infrastructure module* +
package: _infrastructure_
|MyApplicationInfrastructureModule +
resources: myApplicationInfrastructure
|MyConfigurationInfrastructureModule +
resources: myConfigurationInfrastructure

|*Application module* +
package: _application_
|MyApplicationModule +
resources: *my*
|MyConfigurationApplicationModule +
resources: *myConfiguration*

|*PostProcessor module* +
package: _postprocessor_
|MyApplicationPostProcessorModule +
resources: myApplicationPostProcessor
|MyConfigurationPostProcessorModule +
resources: myConfigurationPostProcessor

|===

.Example package structure for application modules
[source,text,indent=0]
[subs="verbatim,quotes,attributes"]
----
com.mypackage
  MyApplication.class
  application.config
    MyApplicationModuleConfiguration.class
  infrastructure.installers
    SchemaInstallerToRunBeforeAnyOtherModule.class
----

Disabling dynamic modules on an `@AcrossApplication` can be done through the *enableDynamicModules* attribute.

WARNING: Dynamic modules perform an automatic component scan of all their child packages with the exception of _installers_ and _extensions_.
If you want the default behavior of scanning only the _config_ child package, you must provide an `AcrossModule` implementation.

NOTE: Manually adding dynamic modules can be done by importing `AcrossDynamicModulesConfiguration` on any configuration class.
This will use the importing class as the base for the dynamic modules.

[[multipart-config]]
== Multipart Filter configuration
TODO

== Static resources
{module-name} automatically enables serving of static resources bundled with modules.
With the default settings static resources will be configured with <<resource-url-versionng,versioned urls>> and <<client-side-caching,client-side caching>>.

=== Conventions
The default resources are served from the */views* folder on the classpath.
By default {module-name} will serve resources from:

* /views/js
* /views/css
* /views/static

Additional subfolders can be configured with the *acrossWebModule.resources.folders* property.

By convention (and for best development mode support) module specific resources should be located in a subfolder with the `resourcesKey` of the module.

.Example resources layout for MyModule
[source,text,indent=0]
[subs="verbatim,quotes,attributes"]
----
src/main/resources
   views/
     static/
       MyModule/
         js/controller.js
         css/my-module.css
         img/logo.png
     th/
       MyModule/
         controller.thtml
         user-profile.thtml
----

The relative path under which the static resources are available is determined by the *acrossWebModule.resources.path* property.

[[client-side-caching]]
=== Client-side caching
By default static resources will be cached on the client-side for a period of 1 year.
Disabling client-side caching is done with the *acrossWebModule.resources.caching.enabled* property.
If client-side caching is disabled, no cache headers will be sent to the client.

Configuring the caching period is done separately with the *acrossWebModule.resources.caching.period* property.
Setting the value to *0* with caching enabled will sent *no-cache* headers.
This is also the default if development mode is active.

[[resource-url-versioning]]
=== Resource URL versioning
By default {module-name} enables link:http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/mvc.html#mvc-config-static-resources[Spring versioning of static resources].
This will generate versioned URLs, create a `ResourceUrlProvider` bean and add a `ResourceUrlEncodingFilter` and `ResourceUrlProviderExposingInterceptor` to the request handlers.

Using versioned resource URLs is transparent:

* in Thymeleaf all relative links added with `@{/relative/path}` will be rewritten if necessary
* in JSP the equivalent is the `<spring:url value="/relative/path" var="url"/>` tag

Using these will work both with or without resource versioning.

WARNING: If versioning is disabled, the `ResourceUrlProvider` will not be available on the request.
Modules using accessing the `ResourceUrlProvider` directly should built-in support for this.

==== Fixed version strategy
{module-name} supports automatic configuration of resource versioning using a single fixed version.
When enabled this means that resources of the form */across/resources/static/mymodule/mymodule.css* will get rewritten to */across/resources/static/VERSION/mymodule/mymodule.css*.

The fixed version used is determined as follows:

. *acrossWebModule.resources.versioning.version* property
. *build.number* property
. version of the {module-name}

Using the fixed version strategy works well for relative includes in both CSS and JS files, avoiding the need to rewrite URLs inside those files.

==== Customizing the version strategy
It is possible to keep configuration of the default resources active but only change the version strategy used.
This can be done by injecting your own `VersionResourceResolver` bean named *versionResourceResolver* the {module-name} context.

.Example providing custom version strategy
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@ModuleConfiguration(AcrossWebModule.NAME)
public static class CustomVersionResourceResolver
{
	@Bean
	public VersionResourceResolver versionResourceResolver() {
		return new VersionResourceResolver()
				.addVersionStrategy( new FixedVersionStrategy( "1.0" ), "/**/*.css" )
				.addVersionStrategy( new FixedVersionStrategy( "2.0" ), "/**" );
	}
}
----

NOTE: Because of limitations of the `CssLinkTransformer` in combination with a fixed version strategy, {module-name} does not rewrite links inside css files.
If you absolutely need this in your application, you will have to disable the automatic resource versioning and configure it yourself.

== Development mode support
{module-name} supports development mode retrieval of physical resources.
If the conventions for static resources and Thymeleaf templates were followed, these will be fetched automatically from their physical location.
This ensures that an application restart is not required for static resources or Thymeleaf rendering.

If development mode is active {module-name} will also send no-cache headers for static resources and will use a generated fixed version if versioning is enabled.

== JSP and Thymeleaf integration
If both JSP and Thymeleaf support are enabled, you can easily use both view types at the same time.  The `{module-name}`
 also provides a tag that can be used to import Thymeleaf templates or fragments in a JSP rendering pipeline.  The same
 model (request attributes) should be available in the Thymeleaf template as in the calling JSP.

[source,html,indent=0]
[subs="verbatim,attributes"]
----
<%@ taglib prefix="across" uri="http://across.foreach.com/tags" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<title>JSP including a Thymeleaf template</title>
</head>
<body>
	<across:thymeleaf template="th/mymodule/thymeleaf-from-jsp-include" />
	<div class="child">
		<across:thymeleaf template="th/mymodule/thymeleaf-from-jsp-include :: fragment" />
	</div>
</body>
</html>
----

[[web-templates]]
== Templates
Named web templates + autodetection

link builders:
prefixing path context
special characters:
- ! = suppress prefix
- {adminWeb}/boe/test/

[[dynamic-servlet-registration]]
== Registering servlets and filters
It is possible to register `Servlet` and `Filter` instances from within an Across module.
This can be easily done by implementing an `AcrossWebDynamicServletConfigurer` bean that will give you access to a configurable `ServletContext`.
During bootstrap, {module-name} will detect all `AcrossWebDynamicServletConfigurer` beans and execute them <<ordering-beans,in order>>.

.Example registering the resourceUrlrEncodingFilterConfiguration after all other filters
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@Order(Ordered.LOWEST_PRECEDENCE)
@Configuration("resourceUrlEncodingFilterConfiguration")
@ConditionalOnProperty(value = "acrossWebModule.resources.versioning", matchIfMissing = true)
public static class ResourceUrlEncodingFilterConfiguration extends AcrossWebDynamicServletConfigurer
{
	public static final String FILTER_NAME = "ResourceUrlEncodingFilter";

	private static final Logger LOG = LoggerFactory.getLogger( ResourceUrlEncodingFilterConfiguration.class );

	@Override
	protected void dynamicConfigurationAllowed( ServletContext servletContext ) throws ServletException {
		FilterRegistration.Dynamic resourceUrlEncodingFilter
			= servletContext.addFilter( FILTER_NAME, new ResourceUrlEncodingFilter() );
		resourceUrlEncodingFilter.addMappingForUrlPatterns(
			EnumSet.of(
					DispatcherType.REQUEST,
					DispatcherType.ERROR,
					DispatcherType.ASYNC
			),
			true,
			"/*"
		);
	}

	@Override
	protected void dynamicConfigurationDenied( ServletContext servletContext ) throws ServletException {
		LOG.warn( "Unable to auto configure ResourceUrlEncodingFilter." );
	}
}
----

NOTE: By default `AcrossWebDynamicServletConfigurer` requires a synchronous startup of the `ServletContext`.
However a fallback method will be called if the bootstrap is not synchronous (`dynamicConfigurationDenied()`).

[[default-http-encoding]]
== Default HTTP encoding
{module-name} registers a default `CharacterEncodingFilter` that forces the request and response encoding to use UTF-8.
This is done through the `HttpEncodingAutoConfiguration` from Spring Boot and can be controlled with the following properties:

* spring.http.encoding.enabled
* spring.http.encoding.charset
* spring.http.encoding.force

If a `CharacterEncodingFilter` bean is found in the parent `ApplicationContext` but default HTTP encoding is enabled, {module-name} will take care of registering that filter bean.

TODO:

mention serving of thymeleaf files
registering resources in a web resource registry
Extending modules should just define a WebMvcConfigurer component or configuration (does not need to be exposed).
To avoid the default configuration: extend AcrossWebModule and override default context configurers.
If you want to add a custom validator/message codes resolver: add it as bean to the AcrossWebModule before bootstrap.
Working with templates
Building menus
Multipart resolving/multipart configuration

